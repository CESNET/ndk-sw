import fdt
from collections.abc import Iterable
from typing import Optional, Union, List, Tuple

from . import eth as mod_eth


def open(path: Optional[str] = None) -> Nfb: ...

class Nfb:
    default_dev_path: str
    fdt: fdt.Fdt
    ndp: QueueManager
    eth: mod_eth.EthManager

    def __init__(self, path: str) -> None: ...
    def fdt_get_compatible(self, compatible: str) -> list[fdt.items.Node]: ...
    def comp_open(self, comp: str | fdt.items.Node, index: int=0) -> Comp: ...
    def fdt_get_phandle(self, phandle: int) -> Optional[fdt.items.Node]: ...
    def read_temperature(self, units: str = "celsius") -> float: ...

class AbstractBaseComp:
    def __init__(self, dev: str | Nfb = Nfb.default_dev_path, node: Optional[fdt.Node]=None, index: int=0):
        self._dev: Nfb
        self._node: fdt.Node

class Comp:
    def __init__(self, dev: str | Nfb, node: Optional[fdt.Node], index: int):
        self._dev: Nfb
        self._node: fdt.Node

    def read(self, addr: int, count: int) -> bytes: ...
    def write(self, addr: int, data: bytes) -> None: ...
    def read8(self, addr: int) -> int: ...
    def read16(self, addr: int) -> int: ...
    def read32(self, addr: int) -> int: ...
    def read64(self, addr: int) -> int: ...
    def write8(self, addr: int, data: int) -> None: ...
    def write16(self, addr: int, data: int) -> None: ...
    def write32(self, addr: int, data: int) -> None: ...
    def write64(self, addr: int, data: int) -> None: ...
    def set_bit(self, addr: int, bit: int, value: bool = True, width: int = 32) -> None: ...
    def get_bit(self, addr: int, bit: int, width: int = 32) -> bool: ...
    def clr_bit(self, addr: int, bit: int, width: int = 32) -> None: ...
    def wait_for_bit(self, addr: int, bit: int, timeout: float = 5.0, delay: float = 0.01, level: bool = True, width: int = 32) -> bool: ...
    def lock(self, features: int, timeout: Optional[int] = None) -> None: ...
    def unlock(self, features: int) -> None: ...

class NdpQueue:
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def read_stats(self) -> dict[str, int]: ...
    def reset_stats(self) -> None: ...

class NdpQueueRx(NdpQueue):
    def recv(self, cnt: int = -1, timeout: float = 0, i: Optional[Union[int, List[int]]] = None) -> list[Tuple[bytes, int]]: ...
    def recvmsg(self, cnt: int = -1, timeout: float = 0, i: Optional[Union[int, List[int]]] = None) -> list[Tuple[Tuple[bytes, bytes, int], int]]: ...

class NdpQueueTx(NdpQueue):
    def send(self, pkts: Union[bytes, List[bytes]], hdrs: Optional[Union[bytes, List[bytes]]] = None, flags: Optional[Union[int, List[int]]] = None, flush: bool = True) -> None: ...
    def sendmsg(self, pkts: Tuple[bytes, bytes, int] | List[Tuple[bytes, bytes, int]], flush: bool = True) -> None: ...
    def flush(self) -> None: ...

class QueueManager:
    def __init__(self, nfb: Nfb) -> None:
        self.rx: list[NdpQueueRx]
        self.tx: list[NdpQueueTx]

    def start(self, i: Optional[Union[int, List[int]]] = None) -> None: ...
    def stop(self, i: Optional[Union[int, List[int]]] = None) -> None: ...
    def send(self, pkts: Union[bytes, Iterable[bytes]], hdrs: Optional[Union[bytes, Iterable[bytes]]] = None, flags: Optional[Union[int, Iterable[int]]] = None, flush: bool = True, i: Optional[Union[int, List[int]]] = None) -> None: ...
    def sendmsg(self, pkts: Tuple[bytes, bytes, int] | Iterable[Tuple[bytes, bytes, int]], flush: bool = True, i: Optional[Union[int, List[int]]] = None) -> None: ...
    def flush(self, i: Optional[Iterable[int] | int] = None) -> None: ...
    def recv(self, cnt: int = -1, timeout: float = 0, i: Optional[Union[int, List[int]]] = None) -> list[Tuple[bytes, int]]: ...
    def recvmsg(self, cnt: int = -1, timeout: float = 0, i: Optional[Union[int, List[int]]] = None) -> list[Tuple[Tuple[bytes, bytes, int], int]]: ...
